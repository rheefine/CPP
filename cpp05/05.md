# C++ - Module 05
## 반복과 예외처리

### 개요
이 문서는 C++ 모듈의 Module 05 과제들을 포함하고 있습니다.
버전: 10.1

### 목차
I. 소개
II. 일반 규칙
III. 연습문제 00: 엄마, 나 커서 공무원이 될래요!
IV. 연습문제 01: 서식 작성, 이것들아!
V. 연습문제 02: 28C가 아니라 28B 서식이 필요해...
VI. 연습문제 03: 커피 타는 것보다는 낫네
VII. 제출 및 동료평가

### Chapter I
#### 소개

C++는 Bjarne Stroustrup이 C 프로그래밍 언어의 확장으로 만든 범용 프로그래밍 언어이며, "클래스가 있는 C"라고도 합니다 (출처: Wikipedia).

이 모듈들의 목표는 여러분에게 객체 지향 프로그래밍을 소개하는 것입니다. 이것은 여러분의 C++ 여정의 시작점이 될 것입니다. OOP를 배우는데 많은 언어들이 추천되지만, 우리는 여러분이 이미 잘 알고 있는 C에서 파생된 C++를 선택했습니다. 이것이 복잡한 언어이기 때문에, 일을 단순하게 하기 위해 여러분의 코드는 C++98 표준을 준수해야 합니다.

우리는 현대 C++가 많은 측면에서 매우 다르다는 것을 알고 있습니다. 따라서 만약 여러분이 능숙한 C++ 개발자가 되기를 원한다면, 42 공통 교육과정 이후에 더 나아가는 것은 여러분의 몫입니다!

### Chapter II
#### 일반 규칙

##### 컴파일
- c++로 코드를 컴파일하며 다음 플래그들을 사용합니다: -Wall -Wextra -Werror
- -std=c++98 플래그를 추가해도 코드가 컴파일되어야 합니다

##### 형식 및 명명 규칙
- 연습문제 디렉토리는 다음과 같이 명명됩니다: ex00, ex01, ... , exn
- 가이드라인에서 요구하는 대로 파일, 클래스, 함수, 멤버 함수 및 속성의 이름을 지정하십시오
- 클래스 이름은 UpperCamelCase 형식으로 작성하십시오. 클래스 코드가 포함된 파일은 항상 클래스 이름에 따라 명명됩니다. 예시:
  - ClassName.hpp/ClassName.h, ClassName.cpp, 또는 ClassName.tpp
  - 예를 들어, 벽돌 벽을 나타내는 "BrickWall" 클래스의 정의를 포함하는 헤더 파일의 이름은 BrickWall.hpp가 됩니다.
- 달리 명시되지 않는 한, 모든 출력 메시지는 개행 문자로 끝나야 하며 표준 출력으로 표시되어야 합니다
- 안녕히 가세요 Norminette! C++ 모듈에서는 어떤 코딩 스타일도 강제되지 않습니다. 여러분이 선호하는 것을 따르면 됩니다. 하지만 동료 평가자가 이해할 수 없는 코드는 평가할 수 없는 코드라는 것을 명심하십시오. 깨끗하고 읽기 쉬운 코드를 작성하도록 최선을 다하십시오.

##### 허용/금지 사항
더 이상 C로 코딩하지 않습니다. C++ 시간입니다! 따라서:
- 표준 라이브러리의 거의 모든 것을 사용할 수 있습니다. 따라서 이미 알고 있는 것에 얽매이는 대신, 가능한 한 많이 여러분이 사용하던 C 함수들의 C++ 버전을 사용하는 것이 현명할 것입니다.
- 그러나 다른 외부 라이브러리는 사용할 수 없습니다. C++11 (및 파생형) 및 Boost 라이브러리가 금지됩니다. 다음 함수들도 금지됩니다: *printf(), *alloc() 및 free(). 이것들을 사용하면 여러분의 점수는 0점이 될 것입니다.
- 명시적으로 달리 명시되지 않는 한, using namespace <ns_name> 및 friend 키워드는 금지됩니다. 그렇지 않으면 점수가 -42점이 될 것입니다.
- Module 08과 09에서만 STL을 사용할 수 있습니다. 즉:
  - 그때까지는 Containers (vector/list/map/기타 등등)와 Algorithms (<algorithm> 헤더를 포함해야 하는 모든 것)을 사용할 수 없습니다. 그렇지 않으면 점수가 -42점이 될 것입니다.

##### 몇 가지 디자인 요구사항
- C++에서도 메모리 누수가 발생합니다. new 키워드를 사용하여 메모리를 할당할 때는 메모리 누수를 피해야 합니다.
- Module 02부터 Module 09까지, 명시적으로 달리 명시되지 않는 한 클래스는 정통 정규 형식(Orthodox Canonical Form)으로 설계되어야 합니다.
- 함수 템플릿을 제외하고 헤더 파일에 넣은 함수 구현은 연습문제 점수 0점을 의미합니다.
- 각각의 헤더를 다른 것들과 독립적으로 사용할 수 있어야 합니다. 따라서 필요한 모든 종속성을 포함해야 합니다. 그러나 include guard를 추가하여 이중 포함 문제를 피해야 합니다. 그렇지 않으면 점수가 0점이 될 것입니다.

##### 참고 사항
- 필요한 경우 추가 파일을 추가할 수 있습니다 (예: 코드를 분할하기 위해). 이러한 과제들은 프로그램으로 검증되지 않으므로, 필수 파일을 제출하는 한 자유롭게 그렇게 하십시오.
- 때로는 연습문제의 지침이 짧아 보이지만 예제에서 명시적으로 작성되지 않은 요구사항을 보여줄 수 있습니다.
- 각 모듈을 시작하기 전에 완전히 읽으십시오! 정말로 그렇게 하십시오.
- 오딘과 토르의 이름으로! 두뇌를 사용하세요!!!

많은 클래스들을 구현해야 할 것입니다. 이는 지루해 보일 수 있지만,
선호하는 텍스트 에디터를 스크립팅할 수 있다면 그렇지 않을 것입니다.

연습문제를 완성하기 위한 어느 정도의 자유가 주어집니다.
하지만 필수 규칙을 따르고 게으르지 마세요. 많은 유용한 정보를
놓칠 수 있습니다! 이론적 개념에 대해 읽는 것을 주저하지 마세요.

### Chapter III
#### 연습문제 00: 엄마, 나 커서 공무원이 될래요!

사무실, 복도, 서식, 대기열의 인위적인 악몽을 설계해 봅시다.
재미있나요? 아니요? 너무 안타깝네요.

먼저, 이 거대한 관료제 기계에서 가장 작은 톱니바퀴부터 시작하겠습니다: Bureaucrat(관료).

Bureaucrat은 다음을 가져야 합니다:
- 상수 이름
- 1(가능한 가장 높은 등급)부터 150(가능한 가장 낮은 등급)까지의 등급

잘못된 등급으로 Bureaucrat을 인스턴스화하려는 모든 시도는 예외를 발생시켜야 합니다:
Bureaucrat::GradeTooHighException 또는 Bureaucrat::GradeTooLowException 중 하나.

이 두 속성에 대한 getter를 제공해야 합니다: getName() 및 getGrade(). 또한 관료의 등급을 증가시키거나 감소시키는 두 개의 멤버 함수를 구현하십시오. 등급이 범위를 벗어나면, 둘 다 생성자와 동일한 예외를 발생시킬 것입니다.

기억하세요. 등급 1이 가장 높고 150이 가장 낮기 때문에,
등급 3을 증가시키면 관료의 등급은 2가 되어야 합니다.

발생한 예외는 try와 catch 블록을 사용하여 잡을 수 있어야 합니다:

```cpp
try
{
    /* 관료들과 관련된 작업 수행 */
}
catch (std::exception & e)
{
    /* 예외 처리 */
}
```

다음과 같은 내용을 출력하는 삽입(<<) 연산자의 오버로드를 구현해야 합니다(꺾쇠 괄호 없이):
<이름>, bureaucrat grade <등급>.

평소와 같이 모든 것이 예상대로 작동한다는 것을 증명하는 테스트를 제출하십시오.

### Chapter IV
#### 연습문제 01: 서식 작성, 이것들아!

이제 관료들이 있으니, 그들에게 할 일을 주도록 하겠습니다. 서식들의 더미를 채우는 것보다 더 좋은 활동이 있을까요?

그러면 Form 클래스를 만들어봅시다. 다음을 가져야 합니다:
- 상수 이름
- 서명되었는지 여부를 나타내는 불리언 (생성 시에는 서명되지 않음)
- 서명에 필요한 상수 등급
- 실행에 필요한 상수 등급

이 모든 속성은 protected가 아닌 private입니다.

Form의 등급은 Bureaucrat에 적용되는 것과 동일한 규칙을 따릅니다. 따라서 폼 등급이 범위를 벗어나면 다음 예외가 발생합니다:
Form::GradeTooHighException 및 Form::GradeTooLowException.

이전과 마찬가지로 모든 속성에 대한 getter와 폼의 모든 정보를 출력하는 삽입(<<) 연산자 오버로드를 작성하십시오.

또한 Form에 Bureaucrat을 매개변수로 받는 beSigned() 멤버 함수를 추가하십시오. 관료의 등급이 충분히 높으면(필요한 등급보다 높거나 같으면) 폼 상태를 서명됨으로 변경합니다. 등급 1이 등급 2보다 높다는 것을 기억하십시오.
등급이 너무 낮으면 Form::GradeTooLowException을 발생시킵니다.

마지막으로 Bureaucrat에 signForm() 멤버 함수를 추가하십시오. 폼이 서명되면 다음과 같이 출력됩니다:
<관료> signed <폼>

그렇지 않으면 다음과 같이 출력됩니다:
<관료> couldn't sign <폼> because <이유>.

모든 것이 예상대로 작동하는지 확인하기 위한 테스트를 구현하고 제출하십시오.

### Chapter V
#### 연습문제 02: 28C가 아니라 28B 서식이 필요해...

이제 기본적인 폼이 있으니, 실제로 무언가를 하는 폼을 몇 개 더 만들어봅시다.

모든 경우에, 기본 클래스 Form은 추상 클래스여야 하며, 따라서 AForm으로 이름을 변경해야 합니다. 폼의 속성은 기본 클래스에 있고 private으로 유지되어야 한다는 점을 기억하십시오.

다음 구체적인 클래스들을 추가하십시오:

- ShrubberyCreationForm: 필요 등급: 서명 145, 실행 137
  작업 디렉토리에 <target>_shrubbery 파일을 만들고 그 안에 ASCII 트리를 작성합니다.

- RobotomyRequestForm: 필요 등급: 서명 72, 실행 45
  드릴 소리를 냅니다. 그런 다음 50%의 확률로 <target>이 성공적으로 로봇화되었다고 알리고, 그렇지 않으면 로봇화가 실패했다고 알립니다.

- PresidentialPardonForm: 필요 등급: 서명 25, 실행 5
  <target>이 Zaphod Beeblebrox에 의해 사면되었음을 알립니다.

이 모든 것은 생성자에서 하나의 매개변수만 받습니다: 폼의 대상입니다. 예를 들어, 집에 관목을 심고 싶다면 "home"이 됩니다.

이제 기본 폼에 execute(Bureaucrat const & executor) const 멤버 함수를 추가하고 구체적인 클래스들의 폼 동작을 실행하는 함수를 구현하십시오. 폼이 서명되었고 실행하려는 관료의 등급이 충분히 높은지 확인해야 합니다. 그렇지 않으면 적절한 예외를 발생시킵니다.

요구사항을 모든 구체적인 클래스에서 확인할지, 아니면 기본 클래스에서 확인한 다음 다른 함수를 호출하여 폼을 실행할지는 여러분의 선택입니다. 하지만 한 방법이 다른 것보다 더 우아합니다.

마지막으로 Bureaucrat에 executeForm(AForm const & form) 멤버 함수를 추가하십시오. 이는 폼을 실행하려고 시도해야 합니다. 성공하면 다음과 같이 출력합니다:
<관료> executed <폼>

실패하면 명시적인 오류 메시지를 출력합니다.

모든 것이 예상대로 작동하는지 확인하기 위한 테스트를 구현하고 제출하십시오.

### Chapter VI
#### 연습문제 03: 커피 타는 것보다는 낫네

서식을 작성하는 것이 충분히 귀찮기 때문에, 우리의 관료들에게 이것을 하루 종일 하라고 하는 것은 잔인할 것입니다. 다행히도 인턴이 존재합니다. 이 연습문제에서는 Intern 클래스를 구현해야 합니다. 인턴은 이름도, 등급도, 특별한 특성도 없습니다. 관료들이 신경 쓰는 유일한 것은 그들이 일을 한다는 것입니다.

하지만 인턴은 한 가지 중요한 능력이 있습니다: makeForm() 함수입니다. 이는 두 개의 문자열을 받습니다. 첫 번째는 폼의 이름이고 두 번째는 폼의 대상입니다. 이는 Form 객체에 대한 포인터를 반환합니다(이름은 매개변수로 전달된 것). 이 객체의 대상은 두 번째 매개변수로 초기화됩니다.

다음과 같이 출력합니다:
Intern creates <폼>

매개변수로 전달된 폼 이름이 존재하지 않으면 명시적인 오류 메시지를 출력합니다.

if/elseif/else 숲과 같은 읽기 어렵고 보기 흉한 해결책은 피해야 합니다. 이런 종류의 것들은 평가 과정에서 받아들여지지 않을 것입니다. 여러분은 더 이상 Piscine(풀)에 있지 않습니다. 평소와 같이 모든 것이 예상대로 작동하는지 테스트해야 합니다.

예를 들어, 아래 코드는 "Bender"를 대상으로 하는 RobotomyRequestForm을 생성합니다:

```cpp
{
    Intern someRandomIntern;
    Form* rrf;
    rrf = someRandomIntern.makeForm("robotomy request", "Bender");
}
```

### Chapter VII
#### 제출 및 동료평가

평소와 같이 Git 저장소에 과제를 제출하십시오. 방어 중에는 저장소 안의 작업만 평가됩니다. 폴더와 파일의 이름이 올바른지 확인하기 위해 다시 한 번 확인하는 것을 주저하지 마십시오.
