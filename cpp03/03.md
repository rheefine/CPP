# C++ - 모듈 03
상속

요약:
이 문서는 C++ 모듈의 모듈 03 연습문제들을 포함하고 있습니다.
버전: 7

## 목차
I 소개 2
II 일반 규칙 3
III 연습문제 00: Aaaaand... OPEN! 5
IV 연습문제 01: Serena, my love! 7
V 연습문제 02: 반복적인 작업 8
VI 연습문제 03: 이제는 이상해! 9
VII 제출 및 동료 평가 11

# Chapter I
## 소개
C++는 Bjarne Stroustrup이 C 프로그래밍 언어의 확장으로, 또는 "클래스가 있는 C"로 만든 범용 프로그래밍 언어입니다 (출처: Wikipedia).

이 모듈들의 목표는 객체 지향 프로그래밍을 소개하는 것입니다.

이것은 당신의 C++ 여정의 시작점이 될 것입니다. OOP를 배우기 위해 추천되는 언어들이 많이 있습니다. 우리는 C++가 당신의 오랜 친구인 C에서 파생되었기 때문에 C++를 선택했습니다.

이것이 복잡한 언어이기 때문에, 그리고 일을 단순하게 유지하기 위해, 당신의 코드는 C++98 표준을 준수할 것입니다.

우리는 현대 C++가 많은 측면에서 매우 다르다는 것을 알고 있습니다. 따라서 만약 당신이 능숙한 C++ 개발자가 되고 싶다면, 42 Common Core 이후에 더 나아가는 것은 당신의 몫입니다!

# Chapter II
## 일반 규칙

### 컴파일
- c++와 -Wall -Wextra -Werror 플래그로 코드를 컴파일하세요
- -std=c++98 플래그를 추가해도 코드는 여전히 컴파일되어야 합니다

### 포맷팅과 명명 규칙
- 연습문제 디렉토리는 다음과 같이 명명됩니다: ex00, ex01, ... , exn
- 파일, 클래스, 함수, 멤버 함수와 속성들의 이름은 가이드라인에서 요구하는 대로 지정하세요.
- 클래스 이름은 UpperCamelCase 형식으로 작성하세요. 클래스 코드를 포함하는 파일은 항상 클래스 이름에 따라 명명될 것입니다. 예를 들어:
ClassName.hpp/ClassName.h, ClassName.cpp, 또는 ClassName.tpp. 따라서, 만약 벽돌 벽을 나타내는 "BrickWall" 클래스의 정의를 포함하는 헤더 파일이 있다면, 그 이름은 BrickWall.hpp가 될 것입니다.
- 달리 명시되지 않는 한, 모든 출력 메시지는 새 줄 문자로 끝나야 하며 표준 출력에 표시되어야 합니다.
- Norminette와 작별입니다! C++ 모듈에서는 코딩 스타일이 강제되지 않습니다. 당신이 선호하는 것을 따르면 됩니다. 하지만 동료 평가자들이 이해할 수 없는 코드는 그들이 평가할 수 없는 코드라는 것을 명심하세요. 깨끗하고 읽기 쉬운 코드를 작성하기 위해 최선을 다하세요.

### 허용/금지
당신은 더 이상 C로 코딩하지 않습니다. C++를 할 시간입니다! 따라서:

- 표준 라이브러리의 거의 모든 것을 사용할 수 있습니다. 따라서, 당신이 이미 알고 있는 것에 매달리는 대신, 당신이 익숙한 C 함수들의 C++ 버전을 최대한 많이 사용하는 것이 현명할 것입니다.
- 하지만, 다른 외부 라이브러리는 사용할 수 없습니다. 이는 C++11(및 파생형)과 Boost 라이브러리가 금지되어 있다는 것을 의미합니다. *printf(), *alloc()와 free() 함수들도 금지되어 있습니다. 이것들을 사용하면, 당신의 점수는 0이 될 것이고 그게 끝입니다.
- 명시적으로 달리 명시되지 않는 한, using namespace <ns_name>과 friend 키워드는 금지되어 있습니다. 그렇지 않으면, 당신의 점수는 -42가 될 것입니다.
- 모듈 08과 09에서만 STL을 사용할 수 있습니다. 이는 그때까지는 컨테이너(vector/list/map/기타 등등)와 알고리즘(<algorithm> 헤더를 포함해야 하는 모든 것)을 사용할 수 없다는 것을 의미합니다. 그렇지 않으면, 당신의 점수는 -42가 될 것입니다.

### 몇 가지 설계 요구사항
- 메모리 누수는 C++에서도 발생합니다. 메모리를 할당할 때(new 키워드를 사용하여), 메모리 누수를 피해야 합니다.
- 모듈 02부터 모듈 09까지, 명시적으로 달리 명시되지 않는 한 당신의 클래스들은 정통 정규 형식(Orthodox Canonical Form)으로 설계되어야 합니다.
- 헤더 파일에 있는 모든 함수 구현(함수 템플릿 제외)은 연습문제에 0점을 의미합니다.
- 각각의 헤더를 다른 것들과 독립적으로 사용할 수 있어야 합니다. 따라서, 그들은 필요한 모든 의존성을 포함해야 합니다. 하지만, include 가드를 추가하여 이중 포함 문제를 피해야 합니다. 그렇지 않으면, 당신의 점수는 0이 될 것입니다.

### 읽어보세요
- 필요한 경우 추가 파일을 추가할 수 있습니다(즉, 코드를 분할하기 위해). 이러한 과제들은 프로그램으로 확인되지 않으므로, 필수 파일을 제출하는 한 자유롭게 하시면 됩니다.
- 때때로, 연습문제의 가이드라인은 짧아 보이지만 예제들은 지침에 명시적으로 작성되지 않은 요구사항들을 보여줄 수 있습니다.
- 시작하기 전에 각 모듈을 완전히 읽으세요! 정말로, 그렇게 하세요.
- 오딘과 토르의 이름으로! 당신의 뇌를 사용하세요!!!

많은 클래스들을 구현해야 할 것입니다. 당신이 좋아하는 텍스트 
에디터를 스크립트로 작성할 수 있지 않다면 이것은 지루해 보일 
수 있습니다.

연습문제들을 완료하기 위해 어느 정도의 자유가 주어집니다.
하지만, 필수 규칙들을 따르고 게으르지 마세요. 당신은 많은 
유용한 정보를 놓칠 것입니다! 이론적 개념들에 대해 읽는 것을 
주저하지 마세요.

# Chapter III
## 연습문제 00: Aaaaand... OPEN!

### 연습문제: 00
### Aaaaand... OPEN!
제출 디렉토리: ex00/
제출할 파일들: Makefile, main.cpp, ClapTrap.{h, hpp}, ClapTrap.cpp
금지된 함수들: 없음

먼저, 클래스를 구현해야 합니다! 얼마나 독창적인가요!

이것은 ClapTrap이라고 불릴 것이며 다음과 같은 private 속성들을 [대괄호]에 지정된 값으로 초기화하여 가질 것입니다:

- Name, 생성자에 매개변수로 전달됨
- Hit points (10), ClapTrap의 체력을 나타냄
- Energy points (10)
- Attack damage (0)

ClapTrap이 더 현실적으로 보이도록 다음의 public 멤버 함수들을 추가하세요:

- void attack(const std::string& target);
- void takeDamage(unsigned int amount);
- void beRepaired(unsigned int amount);

ClapTrap이 공격할 때, 대상은 <attack damage>만큼의 hit points를 잃습니다.
ClapTrap이 자신을 수리할 때, <amount>만큼의 hit points를 회복합니다. 공격과 수리는 각각 1 energy point를 소모합니다. 물론, ClapTrap은 hit points나 energy points가 남아있지 않으면 아무것도 할 수 없습니다.

이러한 모든 멤버 함수들에서, 무슨 일이 일어나는지 설명하는 메시지를 출력해야 합니다. 예를 들어, attack() 함수는 다음과 같은 것을 표시할 수 있습니다(물론, 꺾쇠 괄호 없이):

ClapTrap <name>이(가) <target>을(를) 공격하여 <damage>의 데미지를 입혔습니다!

생성자와 소멸자도 메시지를 표시해야 하므로, 동료 평가자들이 그들이 호출되었다는 것을 쉽게 알 수 있습니다.

코드가 예상대로 작동하는지 확인하기 위해 자신만의 테스트를 구현하고 제출하세요.

# Chapter IV
## 연습문제 01: Serena, my love!

### 연습문제: 01
### Serena, my love!
제출 디렉토리: ex01/
제출할 파일들: 이전 연습문제의 파일들 + ScavTrap.{h, hpp}, ScavTrap.cpp
금지된 함수들: 없음

ClapTrap은 절대 충분히 가질 수 없기 때문에, 이제 파생 로봇을 만들 것입니다.

이것은 ScavTrap이라고 명명될 것이며 ClapTrap으로부터 생성자와 소멸자를 상속받을 것입니다. 하지만, 그것의 생성자, 소멸자와 attack()은 다른 메시지를 출력할 것입니다. 결국, ClapTrap들은 자신들의 개성을 인식하고 있습니다.

적절한 생성/소멸 연쇄가 테스트에서 보여져야 합니다. ScavTrap이 생성될 때, 프로그램은 ClapTrap을 구축하는 것으로 시작합니다. 소멸은 역순으로 이루어집니다. 왜일까요?

ScavTrap은 ClapTrap의 속성들을 사용할 것이며(그에 따라 ClapTrap을 업데이트하세요) 다음과 같이 초기화해야 합니다:

- Name, 생성자에 매개변수로 전달됨
- Hit points (100), ClapTrap의 체력을 나타냄
- Energy points (50)
- Attack damage (20)

ScavTrap은 또한 자신만의 특별한 능력을 가질 것입니다:

void guardGate();

이 멤버 함수는 ScavTrap이 이제 Gate keeper 모드에 있다는 것을 알리는 메시지를 표시할 것입니다.

프로그램에 더 많은 테스트를 추가하는 것을 잊지 마세요.

# Chapter V
## 연습문제 02: 반복적인 작업

### 연습문제: 02
### 반복적인 작업
제출 디렉토리: ex02/
제출할 파일들: 이전 연습문제들의 파일들 + FragTrap.{h, hpp}, FragTrap.cpp
금지된 함수들: 없음

ClapTrap을 만드는 것이 아마도 당신의 신경을 건드리기 시작할 것입니다.

이제, ClapTrap으로부터 상속받는 FragTrap 클래스를 구현하세요. 이것은 ScavTrap과 매우 유사합니다. 하지만, 그것의 생성과 소멸 메시지는 달라야 합니다. 적절한 생성/소멸 연쇄가 테스트에서 보여져야 합니다. FragTrap이 생성될 때, 프로그램은 ClapTrap을 구축하는 것으로 시작합니다. 소멸은 역순으로 이루어집니다.

속성들도 마찬가지지만, 이번에는 다른 값들을 가집니다:

- Name, 생성자에 매개변수로 전달됨
- Hit points (100), ClapTrap의 체력을 나타냄
- Energy points (100)
- Attack damage (30)

FragTrap도 특별한 능력을 가지고 있습니다:

void highFivesGuys(void);

이 멤버 함수는 표준 출력에 긍정적인 하이파이브 요청을 표시합니다.

다시 한 번, 프로그램에 더 많은 테스트를 추가하세요.

# Chapter VI
## 연습문제 03: 이제는 이상해!

### 연습문제: 03
### 이제는 이상해!
제출 디렉토리: ex03/
제출할 파일들: 이전 연습문제들의 파일들 + DiamondTrap.{h, hpp}, DiamondTrap.cpp
금지된 함수들: 없음

이 연습문제에서, 당신은 괴물을 만들 것입니다: FragTrap의 절반이고 ScavTrap의 절반인 ClapTrap입니다. 이것은 DiamondTrap이라고 명명될 것이며, FragTrap과 ScavTrap 모두로부터 상속받을 것입니다. 이것은 매우 위험합니다!

DiamondTrap 클래스는 name이라는 private 속성을 가질 것입니다. 이 속성에 ClapTrap 기본 클래스에 있는 것과 정확히 같은 변수 이름을 주세요(여기서는 로봇의 이름에 대해 이야기하는 것이 아닙니다).

더 명확하게 하기 위해, 여기 두 가지 예가 있습니다.
만약 ClapTrap의 변수가 name이라면, DiamondTrap의 것에도 name이라는 이름을 주세요.
만약 ClapTrap의 변수가 _name이라면, DiamondTrap의 것에도 _name이라는 이름을 주세요.

그것의 속성들과 멤버 함수들은 부모 클래스들 중 하나에서 선택될 것입니다:

- Name, 생성자에 매개변수로 전달됨
- ClapTrap::name (생성자의 매개변수 + "_clap_name" 접미사)
- Hit points (FragTrap)
- Energy points (ScavTrap)
- Attack damage (FragTrap)
- attack() (ScavTrap)

두 부모 클래스들의 특별한 함수들 외에도, DiamondTrap은 자신만의 특별한 능력을 가질 것입니다:

void whoAmI();

이 멤버 함수는 자신의 이름과 ClapTrap 이름을 모두 표시할 것입니다.

물론, DiamondTrap의 ClapTrap 서브오브젝트는 한 번, 그리고 단 한 번만 생성될 것입니다. 네, 여기에 트릭이 있습니다.

다시 한 번, 프로그램에 더 많은 테스트를 추가하세요.

-Wshadow와 -Wno-shadow 컴파일러 플래그를 알고 계신가요?

연습문제 03을 하지 않고도 이 모듈을 통과할 수 있습니다.

# Chapter VII 
## 제출 및 동료 평가

평소와 같이 Git 저장소에 과제를 제출하세요. 방어 중에는 저장소 내부의 작업만 평가될 것입니다. 폴더와 파일의 이름이 올바른지 확인하기 위해 두 번 확인하는 것을 주저하지 마세요.