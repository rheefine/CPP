# C++ - Module 07
## C++ 템플릿

### 요약:
본 문서는 C++ 모듈의 Module 07 연습문제들을 포함하고 있습니다.
버전: 7

## 목차
I. 소개
II. 일반 규칙
III. 연습문제 00: 몇 가지 함수로 시작하기
IV. 연습문제 01: Iter
V. 연습문제 02: Array
VI. 제출 및 동료 평가

## I. 소개

C++는 Bjarne Stroustrup이 C 프로그래밍 언어의 확장으로 만든 범용 프로그래밍 언어이며, "클래스가 있는 C"라고도 합니다 (출처: Wikipedia).

이 모듈들의 목표는 객체 지향 프로그래밍을 소개하는 것입니다.
이것이 여러분의 C++ 여정의 시작점이 될 것입니다. OOP를 배우기 위한 많은 언어들이 있지만, 
우리는 여러분의 오랜 친구인 C에서 파생된 C++를 선택했습니다.
이것이 복잡한 언어이기 때문에, 간단하게 유지하기 위해 여러분의 코드는 C++98 표준을 준수해야 합니다.

현대 C++가 많은 면에서 매우 다르다는 것을 알고 있습니다. 그래서 만약 여러분이 
능숙한 C++ 개발자가 되고 싶다면, 42 Common Core 이후에 더 공부하는 것은 여러분의 몫입니다!

## II. 일반 규칙

### 컴파일
* c++와 플래그 -Wall -Wextra -Werror로 코드를 컴파일하세요
* -std=c++98 플래그를 추가해도 코드가 컴파일되어야 합니다

### 포맷팅과 명명 규칙
* 연습문제 디렉토리는 다음과 같이 명명됩니다: ex00, ex01, ..., exn
* 파일, 클래스, 함수, 멤버 함수와 속성의 이름은 가이드라인에서 요구하는 대로 지어야 합니다.
* 클래스 이름은 UpperCamelCase 형식으로 작성하세요. 클래스 코드를 포함하는 파일은 
항상 클래스 이름에 따라 명명됩니다. 예를 들어: 
ClassName.hpp/ClassName.h, ClassName.cpp, 또는 ClassName.tpp. 그래서 만약 
벽돌 벽을 나타내는 "BrickWall" 클래스의 정의를 포함하는 헤더 파일이 있다면, 
그 이름은 BrickWall.hpp가 될 것입니다.
* 달리 명시되지 않는 한, 모든 출력 메시지는 새 줄 문자로 끝나야 하며 표준 출력으로 표시되어야 합니다.
* Norminette와 작별입니다! C++ 모듈에서는 어떤 코딩 스타일도 강제되지 않습니다. 
여러분이 선호하는 것을 따르세요. 하지만 동료 평가자가 이해할 수 없는 코드는 
평가할 수 없는 코드라는 것을 명심하세요. 깨끗하고 읽기 쉬운 코드를 작성하기 위해 최선을 다하세요.

### 허용/금지 사항
더 이상 C로 코딩하는 것이 아닙니다. C++로 할 시간입니다! 따라서:

* 표준 라이브러리의 거의 모든 것을 사용할 수 있습니다. 따라서 이미 알고 있는 것에만 
고집하지 말고, 가능한 한 많이 여러분이 사용하던 C 함수들의 C++ 버전을 사용하는 것이 현명할 것입니다.
* 하지만 다른 외부 라이브러리는 사용할 수 없습니다. 이는 C++11(및 파생형)과 
Boost 라이브러리가 금지된다는 것을 의미합니다. *printf(), *alloc()과 free() 함수들도 
금지됩니다. 이것들을 사용하면 여러분의 점수는 0점이 될 것입니다.
* 명시적으로 달리 명시되지 않는 한, using namespace <ns_name>과 friend 키워드는 
금지됩니다. 그렇지 않으면 여러분의 점수는 -42점이 될 것입니다.
* Module 08과 09에서만 STL을 사용할 수 있습니다. 즉: 
그때까지는 컨테이너(vector/list/map/기타 등등)와 알고리즘(<algorithm> 헤더를 포함해야 하는 
모든 것)을 사용할 수 없습니다. 그렇지 않으면 여러분의 점수는 -42점이 될 것입니다.

### 몇 가지 설계 요구사항
* 메모리 누수는 C++에서도 발생합니다. 메모리를 할당할 때(new 키워드를 사용하여), 
메모리 누수를 피해야 합니다.
* Module 02부터 09까지, 명시적으로 달리 명시되지 않는 한 여러분의 클래스들은 
정통 정규 형식(Orthodox Canonical Form)으로 설계되어야 합니다.
* 함수 템플릿을 제외하고 헤더 파일에 넣은 모든 함수 구현은 연습문제 점수 0점을 의미합니다.
* 여러분은 각각의 헤더를 다른 것들과 독립적으로 사용할 수 있어야 합니다. 따라서 
그들은 필요한 모든 종속성을 포함해야 합니다. 하지만 include guard를 추가하여 
이중 포함 문제를 피해야 합니다. 그렇지 않으면 여러분의 점수는 0점이 될 것입니다.

### 참고 사항
* 필요한 경우 추가 파일을 추가할 수 있습니다(즉, 코드를 분할하기 위해). 이러한 
과제들은 프로그램으로 검증되지 않으므로, 필수 파일을 제출하는 한 자유롭게 그렇게 할 수 있습니다.
* 때로는 연습문제의 가이드라인이 짧아 보이지만 예제에서 지시사항에 명시적으로 
쓰여있지 않은 요구사항을 보여줄 수 있습니다.
* 시작하기 전에 각 모듈을 완전히 읽으세요! 정말로 그렇게 하세요.
* 오딘과 토르여! 여러분의 두뇌를 사용하세요!!!

여러분은 많은 클래스들을 구현해야 할 것입니다. 이것은 지루해 보일 수 있지만, 
여러분이 좋아하는 텍스트 에디터를 스크립트할 수 있다면 그렇지 않을 것입니다.

여러분에게는 연습문제를 완료할 수 있는 어느 정도의 자유가 주어집니다.
하지만 필수 규칙을 따르고 게으르지 마세요. 많은 유용한 정보를 놓칠 수 있습니다! 
이론적 개념에 대해 읽는 것을 주저하지 마세요.

## III. 연습문제 00: 몇 가지 함수로 시작하기

### 연습문제: 00
제출 디렉토리: ex00/
제출할 파일: Makefile, main.cpp, whatever.{h, hpp}
금지된 함수: 없음

다음 함수 템플릿들을 구현하세요:

* swap: 주어진 두 인수의 값을 교환합니다. 아무것도 반환하지 않습니다.
* min: 인수로 전달된 두 값을 비교하여 더 작은 것을 반환합니다. 둘이 같으면 두 번째 것을 반환합니다.
* max: 인수로 전달된 두 값을 비교하여 더 큰 것을 반환합니다. 둘이 같으면 두 번째 것을 반환합니다.

이 함수들은 어떤 타입의 인수로도 호출될 수 있습니다. 유일한 요구사항은 두 인수가 
같은 타입이어야 하고 모든 비교 연산자를 지원해야 한다는 것입니다.

템플릿은 헤더 파일에 정의되어야 합니다.

다음 코드를 실행하면:

```cpp
int main( void ) {
    int a = 2;
    int b = 3;
    
    ::swap( a, b );
    std::cout << "a = " << a << ", b = " << b << std::endl;
    std::cout << "min( a, b ) = " << ::min( a, b ) << std::endl;
    std::cout << "max( a, b ) = " << ::max( a, b ) << std::endl;
    
    std::string c = "chaine1";
    std::string d = "chaine2";
    
    ::swap(c, d);
    std::cout << "c = " << c << ", d = " << d << std::endl;
    std::cout << "min( c, d ) = " << ::min( c, d ) << std::endl;
    std::cout << "max( c, d ) = " << ::max( c, d ) << std::endl;
    
    return 0;
}
```

다음과 같이 출력되어야 합니다:

```
a = 3, b = 2
min(a, b) = 2
max(a, b) = 3
c = chaine2, d = chaine1
min(c, d) = chaine1
max(c, d) = chaine2
```

## IV. 연습문제 01: Iter

### 연습문제: 01
제출 디렉토리: ex01/
제출할 파일: Makefile, main.cpp, iter.{h, hpp}
금지된 함수: 없음

3개의 매개변수를 받고 아무것도 반환하지 않는 함수 템플릿 iter를 구현하세요.

* 첫 번째 매개변수는 배열의 주소입니다.
* 두 번째는 배열의 길이입니다.
* 세 번째는 배열의 모든 요소에 대해 호출될 함수입니다.

여러분의 테스트를 포함하는 main.cpp 파일을 제출하세요. 테스트 실행 파일을 생성하기에 
충분한 코드를 제공하세요.

여러분의 iter 함수 템플릿은 어떤 타입의 배열과도 작동해야 합니다. 세 번째 매개변수는 
인스턴스화된 함수 템플릿일 수 있습니다.

## V. 연습문제 02: Array

### 연습문제: 02
제출 디렉토리: ex02/
제출할 파일: Makefile, main.cpp, Array.{h, hpp}
선택적 파일: Array.tpp
금지된 함수: 없음

T 타입의 요소를 포함하고 다음 동작과 함수를 구현하는 Array 클래스 템플릿을 개발하세요:

* 매개변수 없는 생성: 빈 배열을 생성합니다.
* unsigned int n을 매개변수로 하는 생성: 기본적으로 초기화된 n개의 요소를 가진 배열을 생성합니다.
팁: int * a = new int();를 컴파일한 다음 *a를 표시해보세요.
* 복사에 의한 생성과 할당 연산자. 두 경우 모두, 복사 후 원본 배열이나 그 복사본을 수정해도 
다른 배열에 영향을 주지 않아야 합니다.
* 메모리 할당에 operator new[]를 반드시 사용해야 합니다. 예방적 할당(미리 메모리 할당)은 
금지됩니다. 프로그램은 절대로 할당되지 않은 메모리에 접근해서는 안 됩니다.
* 요소는 첨자 연산자 []를 통해 접근할 수 있습니다.
* [] 연산자로 요소에 접근할 때, 인덱스가 범위를 벗어나면 std::exception이 던져집니다.
* 배열의 요소 수를 반환하는 size() 멤버 함수. 이 멤버 함수는 매개변수를 받지 않으며 
현재 인스턴스를 수정해서는 안 됩니다.

평소와 같이 모든 것이 예상대로 작동하는지 확인하고 여러분의 테스트를 포함하는 
main.cpp 파일을 제출하세요.

## VI. 제출 및 동료 평가

평소와 같이 Git 저장소에 과제를 제출하세요. 방어 중에는 여러분의 저장소 안에 있는 
작업만 평가될 것입니다. 폴더와 파일의 이름이 올바른지 확인하기 위해 다시 한 번 
확인하는 것을 주저하지 마세요.